#!/bin/bash

DIR=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)

VERBOSE=0
RESOLUTION=300
APPEND=0
MAXPAGE=
TRUNCPAGE=0
UNPAPER=0
SEARCHABLE=0
LANGUAGE=eng
SKIP_EMPTY_PAGES=0
OPTIMIZATION=
PAGE_WIDTH=
PAGE_HEIGHT=
PS2PDF_OPTS=
INPUT_DIR=
OUTPUT=

cleanup()
{
  # rm -rf "$INPUT_DIR"
  echo "Cleanup CANCELED!!!!!"
}
trap cleanup EXIT

# Parse command-line options
while [[ $# > 0 ]]; do
  case "$1" in

  --verbose) VERBOSE=1 ;;

  --resolution) shift; RESOLUTION=$1 ;;

  --append) APPEND=1 ;;

  --max) shift; MAXPAGE=$1 ;;

  --truncate) shift; TRUNCPAGE=$1 ;;

  --unpaper) UNPAPER=1 ;;

  --ocr) SEARCHABLE=1 ;;

  --language) shift; LANGUAGE=$1 ;;

  --skip-empty-pages) SKIP_EMPTY_PAGES=1 ;;

  --optimization) shift; OPTIMIZATION=$1 ;;

  --page-width) shift; PAGE_WIDTH=$1 ;;

  --page-height) shift; PAGE_HEIGHT=$1 ;;

  --ps2pdf-opts) shift; PS2PDF_OPTS=$1 ;;

  --input-dir) shift; INPUT_DIR="$1" ;;

  --output) shift; OUTPUT="$1" ;;

  *) echo >&2 "Unknown argument: $1"; exit 1 ;;

  esac
  shift   # next option
done

log()
{
  if [[ $VERBOSE == 1 ]]; then
    echo "scan_postprocessing: $1"
  fi
}

logstdout()
{
  if [[ $VERBOSE == 1 ]]; then
    cat
  else
    cat > /dev/null
  fi
}

runconstrained()
{
  if [[ -x "$(command -v sem)" ]]; then
    # use up to 75% of the cores available
    arg=$(echo "$@" | sed -E 's/([\(\)])/\\\1/g')  # Escaping parenthesis, otherwise the following will fail
    sem --jobs 75% --id scan_postprocessing --fg "$arg"
  else
    "$@"
  fi
}

TIMEVERBOSE=
if [[ $VERBOSE == 1 ]]; then
  TIMEVERBOSE=time
fi

shopt -s extglob nullglob
ppmfiles=($INPUT_DIR/scan-[0-9]*)
numscans=${#ppmfiles[@]}
if (( numscans == 0 )); then
  echo "Found no scans."
  exit 1
fi

for x in ${ppmfiles[@]}; do
  IMAGE_PATH=$x
  IMAGE_DIR=$(dirname $x)
  IMAGE_FILE=$(basename $x)

  if [[ $SKIP_EMPTY_PAGES == 1 ]]; then
    PERCENTAGE_WHITE=$(convert "$IMAGE_PATH" -resize 20% -shave 4%x4% \( +clone -lat ${RESOLUTION/5}x${RESOLUTION/5}-10% -threshold 96% \) -compose lighten -composite -fuzz 0% -negate -threshold 0 -negate -format "%[fx:100*mean]" info:) || PERCENTAGE_WHITE=0
    log "$IMAGE_PATH has $PERCENTAGE_WHITE % white"
  else
    PERCENTAGE_WHITE=0
  fi

  if [[ $SKIP_EMPTY_PAGES == 1 && $(echo "$PERCENTAGE_WHITE > 99.8" | bc -l) == 1 ]]; then
    log "Skipping empty page $IMAGE_FILE with white percentage $PERCENTAGE_WHITE"
  else
    if [[ "$OPTIMIZATION" == "std" ]]; then
      log "Applying optimization script \"$OPTIMIZATION\" to image data..."
      runconstrained $TIMEVERBOSE convert $IMAGE_PATH -level 8%,90% -fuzz 8% -fill white -opaque "rgb(255, 255, 255)" $IMAGE_PATH | logstdout
    fi

    if [[ "$OPTIMIZATION" == "full" ]]; then
      log "Applying optimization script \"$OPTIMIZATION\" to image data..."
      runconstrained $TIMEVERBOSE convert $IMAGE_PATH \( +clone -lat ${RESOLUTION}x${RESOLUTION}-10% -threshold 96% \) -compose lighten -composite $IMAGE_PATH | logstdout
    fi

    if [[ $UNPAPER == 1 ]]; then
      log "Applying unpaper post-processing to image data..."
      PP_PREFIX="unpaper-"
      if [[ $VERBOSE == 1 ]]; then
        UNPAPERVERBOSE="-v"
      fi
      #runconstrained $TIMEVERBOSE unpaper $UNPAPERVERBOSE --no-mask-scan --overwrite --dpi $RESOLUTION --no-blackfilter $IMAGE_FILE $PP_PREFIX$IMAGE_FILE | logstdout
      runconstrained $TIMEVERBOSE unpaper $UNPAPERVERBOSE --overwrite --dpi $RESOLUTION $IMAGE_PATH $IMAGE_DIR/$PP_PREFIX$IMAGE_FILE | logstdout
    fi

    if [[ $SEARCHABLE == 1 ]]; then
      log "Converting image data to searchable pdf..."
      # tesseract uses the input's DPI header, we need to convert to a format that supports this (like tiff)
      log "...Running convert"
      runconstrained $TIMEVERBOSE convert -density ${RESOLUTION}x${RESOLUTION} -units PixelsPerInch $IMAGE_DIR/$PP_PREFIX$IMAGE_FILE $IMAGE_DIR/$PP_PREFIX${IMAGE_FILE}.tiff | logstdout
      log "...Running tesseract"
      runconstrained $TIMEVERBOSE tesseract $IMAGE_DIR/$PP_PREFIX${IMAGE_FILE}.tiff $IMAGE_DIR/${IMAGE_FILE%.*} -l $LANGUAGE pdf | logstdout
      [[ -f $IMAGE_DIR/$PP_PREFIX${IMAGE_FILE}.tiff ]] && rm $IMAGE_DIR/$PP_PREFIX${IMAGE_FILE}.tiff
    else
      log "Converting image data to pdf..."
      if [[ "$PGWIDTHIN" == "" || "$PGHEIGHTIN" == "" ]]; then
        PAGEOPTS="-equalpixels -dpi=$RESOLUTION -noturn"
      else
        PAGEOPTS="-imagewidth $PGWIDTHIN -imageheight $PGHEIGHTIN"
      fi
      PNMVERBOSE=
      # older versions of pnmtops (Ubuntu, Debian) don't have the -verbose option, test for it
      if [[ $VERBOSE == 1 && ! "$(pnmtops -verbose 2>&1 < /dev/null)" =~ "unrecognized option" ]]; then
        PNMVERBOSE="-verbose"
      fi

      log "...Running pnmtops on $IMAGE_DIR/$PP_PREFIX$IMAGE_FILE using page options: $PAGEOPTS"
      runconstrained $TIMEVERBOSE pnmtops $PNMVERBOSE $PAGEOPTS $IMAGE_DIR/$PP_PREFIX$IMAGE_FILE > $IMAGE_DIR/${IMAGE_FILE}.ps | logstdout

      log "...Running ps2pdf on $IMAGE_DIR/${IMAGE_FILE}.ps"
      runconstrained $TIMEVERBOSE ps2pdf14 $PS2PDF_OPTS $IMAGE_DIR/${IMAGE_FILE}.ps $IMAGE_DIR/${IMAGE_FILE}.pdf | logstdout
      [[ -f $IMAGE_DIR/${IMAGE_FILE}.ps ]] && rm $IMAGE_DIR/$PP_PREFIX${IMAGE_FILE}.ps
    fi
  fi

  status=$?
  rm $IMAGE_PATH
  [[ -f $IMAGE_DIR/$PP_PREFIX${IMAGE_FILE} ]] && rm $IMAGE_DIR/$PP_PREFIX${IMAGE_FILE}

  log ""
  log "Scan page processing done, status = $status"
done;


exit 1

shopt -s extglob nullglob
pdffiles=($INPUT_DIR/scan-[0-9]*.pdf)
numscans=${#pdffiles[@]}
if (( numscans > 0 )); then
  echo "Processing $numscans pages"
  if (( TRUNCPAGE > 0 )); then
    truncpage=$TRUNCPAGE
    if (( numscans < TRUNCPAGE )); then
      truncpage=$numscans
    fi
    for x in ${pdffiles[@]:$numscans-$truncpage:$truncpage}; do rm "$x"; done;
    pdffiles=(${pdffiles[@]:0:$numscans-$truncpage})
    echo "Truncated $truncpage pages"
    let "numscans = numscans - truncpage"
  fi
  if (( numscans <= 0 )); then
    echo "Found no scans."
    exit 0
  fi
  if (( numscans > 1 && USEARRAY == 1 )); then
    output_count=${#OUTPUT[@]}
    echo "Naming $numscans pdfs based on output list of $output_count names..."
    index=0
    while (( index < output_count && numscans > index )); do
      let "scanno = index + 1"
      if [[ -f "${OUTPUT[$index]}" ]]; then
        mv "${OUTPUT[$index]}" "${OUTPUT[$index]}.orig"
        if [[ $APPEND == 1 ]]; then
          pdffiles=()
          if [[ -f "${OUTPUT[$index]}.orig" ]]; then
            pdffiles+=("${OUTPUT[$index]}.orig")
          fi
          pdffiles+=($INPUT_DIR/scan-*(0)$scanno.pdf)
          pdfunite "${pdffiles[@]}" "${OUTPUT[$index]}" && rm $INPUT_DIR/scan-*(0)$scanno.pdf
        else
          mv $INPUT_DIR/scan-*(0)$scanno.pdf "${OUTPUT[$index]}"
        fi
      else
        mv $INPUT_DIR/scan-*(0)$scanno.pdf "${OUTPUT[$index]}"
      fi
      let "index = index + 1"
    done
  elif (( numscans > 1 || APPEND == 1 )); then
    echo "Concatenating pdfs..."
    if [[ -f "$OUTPUT" ]]; then
      mv "$OUTPUT" "${OUTPUT}.orig"
    fi
    pdffiles=()
    if [[ -f "${OUTPUT}.orig" ]]; then
      pdffiles+=("${OUTPUT}.orig")
    fi
    pdffiles+=($INPUT_DIR/scan-[0-9]*.pdf)
    pdfunite "${pdffiles[@]}" "$OUTPUT" && rm $INPUT_DIR/scan-[0-9]*.pdf
  else
    if [[ $USEARRAY == 1 ]]; then
      mv $INPUT_DIR/scan-0*.pdf "${OUTPUT[0]}"
    else
      mv $INPUT_DIR/scan-0*.pdf "$OUTPUT"
    fi
  fi
  echo ""
  echo "Done."
else
  echo "Found no scans."
fi
